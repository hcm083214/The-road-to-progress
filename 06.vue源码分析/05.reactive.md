在vue设计与实现4.3设计一个完善的响应系统中提到一个响应式系统的工作流程如下：

1. 当读取操作发生时，将副作用函数收集到“桶”中；
2. 当设置操作发生时，从“桶”中取出副作用函数并执行。

读取操作会调用 track 方法，设置操作会调用 trigger 方法。将断点卡在 track 和 trigger 方法上，看看 vue3 都干了什么。

# getter 和 setter 执行过程探究

下面是用于 debugger 的一个简单的例子：


```html
<div id="app">
    <demo />
</div>
<script src="../../dist/vue.global.js"></script>
<script type="text/x-template" id="item-template">
    <div>{{data.count}}</div>
    <button @click="add">+1</button>
</script>
<script>
    const { reactive, createApp } = Vue
    const demo = {
        template: '#item-template',
        setup() {
            const data = reactive({
                count: 0,
            })
            const add = () => {
                data.count++
            }
            return { data, add }
        }
    }

    Vue.createApp({
        components: {
            demo
        },
    }).mount("#app");
</script>
```
断点卡在 track 上时，刷新页面会发现会有两次进入，调用顺序及调用栈信息分别如下：

第一次：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0074d127e87f47afa72e577408b84144~tplv-k3u1fbpfcp-watermark.image?)

第二次：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40a1aeaa8d82427b893a0249faeec10c~tplv-k3u1fbpfcp-watermark.image?)

为什么执行两次目前先不去探究，但是从两次的调用栈及函数名称大概可以推测出在 track 前vue执行的操作：vue 会解析模板转变成虚拟 DOM，经 render 函数处理，在此过程中触发 get 操作收集副作用函数

断点卡在 trigger 上，点击 +1 ，调用顺序和调用栈信息如下：

第一次：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08e63147f2434461881545c0b37fbbf5~tplv-k3u1fbpfcp-watermark.image?)

第二次：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1eb49914a934201a9126f4ad972c8f7~tplv-k3u1fbpfcp-watermark.image?)

第三次：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b69778fa26a64b55b4035696b8275197~tplv-k3u1fbpfcp-watermark.image?)

执行三次很好理解，在第二次过程中存在异步操作其作用是将副作用函数的执行放入到异步队列中，从 4.7 调度执行可以了解到此部分实现的功能是：在 vue 中如果多次修改同一个响应式数据但是只会触发一次更新。通过这一点你也可以理解为什么会有 nextTick 这个 api 了。

# reactive 执行过程探究

`reactive` 是在源码的 packages --> reactivity --> src --> reactive.ts 中：

```ts
export const mutableHandlers: ProxyHandler<object> = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys
}
export const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {
  get: /*#__PURE__*/ createInstrumentationGetter(false, false)
}
export function reactive(target: object) {
  // if trying to observe a readonly proxy, return the readonly version.
  if (isReadonly(target)) {
    return target
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  )
}
```
这段代码很好理解：如果传入的对象是一个只读的代理对象则直接返回，判断是否为只读的代理对象是通过判断属性上有没有 `__v_isReadonly`。接着直接返回 `createReactiveObject` 的执行结果，`createReactiveObject` 代码如下：

```ts
function createReactiveObject(
  target: Target,
  isReadonly: boolean,
  baseHandlers: ProxyHandler<any>,
  collectionHandlers: ProxyHandler<any>,
  proxyMap: WeakMap<Target, any>
){
  if (!isObject(target)) {
    if (__DEV__) {
      console.warn(`value cannot be made reactive: ${String(target)}`)
    }
    return target
  }
  // target is already a Proxy, return it.
  // exception: calling readonly() on a reactive object
  if (
    target[ReactiveFlags.RAW] &&
    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])
  ) {
    return target
  }
  // target already has corresponding Proxy
  const existingProxy = proxyMap.get(target)
  if (existingProxy) {
    return existingProxy
  }
  // only specific value types can be observed.
  const targetType = getTargetType(target)
  if (targetType === TargetType.INVALID) {
    return target
  }
  const proxy = new Proxy(
    target,
    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers
  )
  proxyMap.set(target, proxy)
  return proxy
}
```
该段代码逻辑也很简单，如果传入的对象满足以下4种情况，直接返回原对象：

- 不是一个对象
- 该对象已经是一个代理对象
- 该对象已经有了关联的代理对象，如果存在相关联的对象在 proxyMap 中能够找到，因为 proxyMap 保存了target 和 proxy 的映射关系
- 传入的对象需要符合代理对象的要求,即 TargetType 属于两大类：common（object，Array）和 collection （Map，Set，WeakMap，WeakSet）

```ts
function targetTypeMap(rawType: string) {
  switch (rawType) {
    case 'Object':
    case 'Array':
      return TargetType.COMMON
    case 'Map':
    case 'Set':
    case 'WeakMap':
    case 'WeakSet':
      return TargetType.COLLECTION
    default:
      return TargetType.INVALID
  }
}
```

最后根据 TargetType 返回代理对象

```ts
// 当 TargetType === common 时，返回的代理对象为
export const mutableHandlers: ProxyHandler<object> = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys
}
new Proxy(
    target,
    mutableHandlers
)
  
// 当 TargetType === collection 时，返回的代理对象为
export const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {
  get: /*#__PURE__*/ createInstrumentationGetter(false, false)
}
new Proxy(
    target,
    mutableCollectionHandlers
)
```
对于 TargetType === common 即传入的对象为 object 和 Array 时，handler 除了拦截 get，set 外，同时还拦截了 deleteProperty，has 和 ownKeys 操作。拦截这三个操作的目的如下：

- deleteProperty：拦截的是 `delete` 操作符，例如 `obj.foo`
- has ：拦截的是 `in` 操作符,例如 `key in obj`
- ownKeys ： 拦截的是`Object.getOwnPropertyNames` 和`Object.getOwnPropertySymbols`，例如 `for(const key in obj)`

了解了代码逻辑外，createReactiveObject  接收 5 个参数：

- target 表示被代理的对象

- isReadonly 表示是否创建只读的响应式对象，以下方法创建的都是只读的响应式对象

  ```ts
  // 接受一个对象 (不论是响应式还是普通的) 或是一个 ref，返回一个原值的只读代理
  export function readonly<T extends object>( target: T ): DeepReadonly<UnwrapNestedRefs<T>> {
    return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    )
  }
  
  // readonly() 的浅层作用形式
  export function shallowReadonly<T extends object>(target: T): Readonly<T> {
    return createReactiveObject(
      target,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
    )
  }
  ```

- baseHandlers 表示 target 类型为 common （Object ,Array ）代理对象的 handler，拦截的操作包括 get,set,deleteProperty,has,ownKeys

- collectionHandlers 表示 target 类型为 collection （Map,Set,WeakMap,WeakSet）代理对象的 handler。拦截的操作只有 get 

- proxyMap 表示是“桶”，记录了 target 和 代理对象的映射关系

  ```ts
  export const reactiveMap = new WeakMap<Target, any>()
  export const shallowReactiveMap = new WeakMap<Target, any>()
  export const readonlyMap = new WeakMap<Target, any>()
  export const shallowReadonlyMap = new WeakMap<Target, any>()
  ```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42b5944d093e45cba93904030bdfde97~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

最后总结下 reactive 函数的执行过程：

1.  reactive 函数接收单个参数 target ，其值必须对象。内部调用 createReactiveObject 方法将对象变成响应式。
2.  对于 target 类型也只能接收两大类：common （Object ,Array ）和 collection（Map,Set,WeakMap,WeakSet）,common 会被劫持 get,set,deleteProperty,has,ownKeys 操作，collection 仅劫持 get 操作，其他的对象类型则不会进行响应式处理

# mutableHandlers 执行过程探究

`baseHandlers ` 是在源码的 packages --> reactivity --> src --> baseHandlers .ts 

baseHandlers 是当代理对象为 Object(普通的对象) 和 Array 的 handler 即 `new Proxy(Target,badeHandlers)`，baseHandlers 处理器传入的值为 mutableHandlers 对象包含了 get,set,deleteProperty,has,ownKeys 5个方法，对了 读，写，删除，in ，for in 这5个操作。

```ts
export const mutableHandlers: ProxyHandler<object> = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys
}

export function reactive(target: object) {
  // if trying to observe a readonly proxy, return the readonly version.
  if (isReadonly(target)) {return target}
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  )
}
```

下面我们分别看下这 5 个方法

## get/has/ownKeys

get 函数是执行 createGetter 方法后得到的， createGetter  接收两个参数默认为 false，分别控制是否为浅响应（shallowGet：只对对象最外层做响应式处理），只读（readonlyGet：数据只能读不能写），浅只读（shallowReadonlyGet：只限制最外层不能改，并且只对外层做响应式处理）。get 函数主要做的以下5件事情：

- 对特殊的key值的处理
- 被代理对象为数组的处理
- 深响应，浅响应，只读，浅只读的处理
- 读取值，并且实现自动脱ref
- track 函数执行，进行依赖收集

细节部分如下：

```ts
const get = /*#__PURE__*/ createGetter()
const shallowGet = /*#__PURE__*/ createGetter(false, true)
const readonlyGet = /*#__PURE__*/ createGetter(true)
const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true)

export const enum ReactiveFlags {
  SKIP = '__v_skip',
  IS_REACTIVE = '__v_isReactive',
  IS_READONLY = '__v_isReadonly',
  IS_SHALLOW = '__v_isShallow',
  RAW = '__v_raw'
}

function createGetter(isReadonly = false, shallow = false) {
  return function get(target: Target, key: string | symbol, receiver: object) {
    //特殊key值的处理
    if (key === ReactiveFlags.IS_REACTIVE) { // key === '__v_isReactive'，如果不是只读，则是响应式
      return !isReadonly
    } else if (key === ReactiveFlags.IS_READONLY) { // key === '__v_isReadonly'，根据传入的 isReadonly 参数决定
      return isReadonly
    } else if (key === ReactiveFlags.IS_SHALLOW) { // key === '__v_isShallow'，根据传入的 shallow 参数决定
      return shallow
    } else if (  // key === '__v_raw'，并且已经记录在 WeakMap 对象内，返回被代理对象，用于 toRaw 方法
      key === ReactiveFlags.RAW &&
      receiver ===
        (isReadonly
          ? shallow
            ? shallowReadonlyMap
            : readonlyMap
          : shallow
          ? shallowReactiveMap
          : reactiveMap
        ).get(target)
    ) {
      return target
    }
	
    // 数组的处理，针对数组查找方法 'includes', 'indexOf', 'lastIndexOf'，
    // 影响数组长度方法 'push', 'pop', 'shift', 'unshift', 'splice' 做特殊的处理  
    /**
    	const arrayInstrumentations = createArrayInstrumentations()
    	function createArrayInstrumentations() {
    		(['includes', 'indexOf', 'lastIndexOf'] as const).forEach( ... )
    		(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach( ... )
    	}
    */  
    const targetIsArray = isArray(target)

    if (!isReadonly) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver)
      }
      if (key === 'hasOwnProperty') {
        return hasOwnProperty
      }
    }

    // 读取属性值，直接返回结果 
    const res = Reflect.get(target, key, receiver)

    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res
    }

    //  track 函数执行，进行依赖收集 
    if (!isReadonly) {
      track(target, TrackOpTypes.GET, key)
    }
	
    // 浅响应直接返回结果  
    if (shallow) {
      return res
    }

    // 自动脱 ref ：读取的值是 ref ，返回它的 value 属性值
    if (isRef(res)) {
      // ref unwrapping - skip unwrap for Array + integer key.
      return targetIsArray && isIntegerKey(key) ? res : res.value
    }

    // 读取的属性值是对象，并且是只读，递归调用 readonly，非只读递归调用 reactive  
    if (isObject(res)) {
      // Convert returned value into a proxy as well. we do the isObject check
      // here to avoid invalid value warning. Also need to lazy access readonly
      // and reactive here to avoid circular dependency.
      return isReadonly ? readonly(res) : reactive(res)
    }

    return res
  }
}
```

has 和 ownKeys 这两个方法相对简单，仅仅是拦截操作调用 track 进行依赖收集

```ts
function has(target: object, key: string | symbol): boolean {
  const result = Reflect.has(target, key)
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, TrackOpTypes.HAS, key)
  }
  return result
}

function ownKeys(target: object): (string | symbol)[] {
  track(target, TrackOpTypes.ITERATE, isArray(target) ? 'length' : ITERATE_KEY)
  return Reflect.ownKeys(target)
}
```

## set/deleteProperty

set 函数是执行 createSetter 方法后得到的， createSetter 接收一个参数默认 false，区分是否为浅响应。set 函数主要做的以下3件事情：

- 区分操作是新增还是修改
- 设置值
- 调用 trigger 函数派发更新

```ts
const set = /*#__PURE__*/ createSetter()
const shallowSet = /*#__PURE__*/ createSetter(true)

function createSetter(shallow = false) {
  return function set(
    target: object,
    key: string | symbol,
    value: unknown,
    receiver: object
  ): boolean {
    let oldValue = (target as any)[key]
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue)
        value = toRaw(value)
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value
        return true
      }
    } else {
      // in shallow mode, objects are set as-is regardless of reactive or not
    }
	// 判断是否为新增还是编辑
    const hadKey =
      isArray(target) && isIntegerKey(key)
        ? Number(key) < target.length
        : hasOwn(target, key)
    const result = Reflect.set(target, key, value, receiver)
    // don't trigger if target is something up in the prototype chain of original
    // target 和 被代理对象判断是为了解决 key 值是在原型链上的属性，set 时会触发两次 trigger 的问题
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, TriggerOpTypes.ADD, key, value)
      } else if (hasChanged(value, oldValue)) {
        trigger(target, TriggerOpTypes.SET, key, value, oldValue)
      }
    }
    return result
  }
}
```

deleteProperty 也相对简单，拦截删除操作调用 trigger 函数派发更新

```ts
function deleteProperty(target: object, key: string | symbol): boolean {
  const hadKey = hasOwn(target, key)
  const oldValue = (target as any)[key]
  const result = Reflect.deleteProperty(target, key)
  if (result && hadKey) {
    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)
  }
  return result
}
```

# mutableCollectionHandlers 执行过程探究

`mutableCollectionHandlers ` 是在源码的 packages --> reactivity --> src --> collectionHandlers .ts 

mutableCollectionHandlers 是当代理对象为 Map,Set,WeakMap,WeakSet 的 handler 即 `new Proxy(Target,mutableCollectionHandlers )`，mutableCollectionHandlers 仅有 get 操作。

```ts
export const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {
  get: /*#__PURE__*/ createInstrumentationGetter(false, false)
}

export function reactive(target: object) {
  // if trying to observe a readonly proxy, return the readonly version.
  if (isReadonly(target)) {return target}
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  )
}
```

Map,Set,WeakMap,WeakSet 为什么只需要拦截 get 操作呢，这是因为这些集合类对象的操作，都是通过调用对象上的方法和属性来完成的。通过拦截 get 操作，key 值传递的是方法名， 重写方法即可。

对于 get 操作的拦截还有一点需要注意：

```ts
new Proxy(target, 
          {
                get(target, key, recevier) {
                    // 不能直接返回 Reflect.get ，否则会一直递归导致栈溢出
                    // return Reflect.get(target, key, recevier)
                    return () => {
                        // 返回的其实需要执行的方法而不是属性
                        return Reflect.get(target, key, recevier)
                    }
                }
            })
```

接下来看下 createInstrumentationGetter 函数的执行，该函数接收两个参数默认都为 false，用来控制是否为浅响应还是只读。主要完成2件事件：

- 对特殊的key值的处理
- 根据传入的参数选择合适的 instrumentations

```ts
export const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {
  get: /*#__PURE__*/ createInstrumentationGetter(false, false)
}

export const shallowCollectionHandlers: ProxyHandler<CollectionTypes> = {
  get: /*#__PURE__*/ createInstrumentationGetter(false, true)
}

export const readonlyCollectionHandlers: ProxyHandler<CollectionTypes> = {
  get: /*#__PURE__*/ createInstrumentationGetter(true, false)
}

export const shallowReadonlyCollectionHandlers: ProxyHandler<CollectionTypes> = {
  get: /*#__PURE__*/ createInstrumentationGetter(true, true)
}
function createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {
  const instrumentations = shallow
    ? isReadonly
      ? shallowReadonlyInstrumentations
      : shallowInstrumentations
    : isReadonly
    ? readonlyInstrumentations
    : mutableInstrumentations

  return (
    target: CollectionTypes,
    key: string | symbol,
    receiver: CollectionTypes
  ) => {
    if (key === ReactiveFlags.IS_REACTIVE) {
      return !isReadonly
    } else if (key === ReactiveFlags.IS_READONLY) {
      return isReadonly
    } else if (key === ReactiveFlags.RAW) {
      return target
    }

    return Reflect.get(
      hasOwn(instrumentations, key) && key in target
        ? instrumentations
        : target,
      key,
      receiver
    )
  }
}
```

instrumentations 又是调用 createInstrumentations 函数生成的,可以看出对于集合对象的 get,has,add,set,delete,clear,forEach 方法，size 属性均进行了重写

```ts
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* #__PURE__*/ createInstrumentations()

function createInstrumentations() {
  const mutableInstrumentations: Record<string, Function | number> = {
    get(this: MapTypes, key: unknown) {
      return get(this, key)
    },
    get size() {
      return size(this as unknown as IterableCollections)
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  }

  const shallowInstrumentations: Record<string, Function | number> = {
    get(this: MapTypes, key: unknown) {
      return get(this, key, false, true)
    },
    get size() {
      return size(this as unknown as IterableCollections)
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  }

  const readonlyInstrumentations: Record<string, Function | number> = {
    get(this: MapTypes, key: unknown) {
      return get(this, key, true)
    },
    get size() {
      return size(this as unknown as IterableCollections, true)
    },
    has(this: MapTypes, key: unknown) {
      return has.call(this, key, true)
    },
    add: createReadonlyMethod(TriggerOpTypes.ADD),
    set: createReadonlyMethod(TriggerOpTypes.SET),
    delete: createReadonlyMethod(TriggerOpTypes.DELETE),
    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),
    forEach: createForEach(true, false)
  }

  const shallowReadonlyInstrumentations: Record<string, Function | number> = {
    get(this: MapTypes, key: unknown) {
      return get(this, key, true, true)
    },
    get size() {
      return size(this as unknown as IterableCollections, true)
    },
    has(this: MapTypes, key: unknown) {
      return has.call(this, key, true)
    },
    add: createReadonlyMethod(TriggerOpTypes.ADD),
    set: createReadonlyMethod(TriggerOpTypes.SET),
    delete: createReadonlyMethod(TriggerOpTypes.DELETE),
    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),
    forEach: createForEach(true, true)
  }

  const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator]
  iteratorMethods.forEach( ... )

  return [
    mutableInstrumentations,
    readonlyInstrumentations,
    shallowInstrumentations,
    shallowReadonlyInstrumentations
  ]
}
```

## get

get 函数接收 4 个参数，isReadonly,isShallow 默认为 false，主要功能如下：

- track 函数执行，进行依赖收集
- 根据 isReadonly,isShallow 是否需要深响应和只读

```ts
function get(
  target: MapTypes,
  key: unknown,
  isReadonly = false,
  isShallow = false
) {
  // #1772: readonly(reactive(Map)) should return readonly + reactive version
  // of the value
  target = (target as any)[ReactiveFlags.RAW]
  const rawTarget = toRaw(target)
  const rawKey = toRaw(key)
  if (!isReadonly) {
    if (key !== rawKey) {
      track(rawTarget, TrackOpTypes.GET, key)
    }
    track(rawTarget, TrackOpTypes.GET, rawKey)
  }
  const { has } = getProto(rawTarget)
  // wrap 是根据 isReadonly,isShallow 选择的函数，其值如下：
  /**
  	const toShallow = <T extends unknown>(value: T): T => value
  	export const toReadonly = <T extends unknown>(value: T): T =>
  		isObject(value) ? readonly(value as Record<any, any>) : value
  	export const toReactive = <T extends unknown>(value: T): T =>
  		isObject(value) ? reactive(value) : value	
  */
  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive
  if (has.call(rawTarget, key)) {
    return wrap(target.get(key))
  } else if (has.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey))
  } else if (target !== rawTarget) {
    // #3602 readonly(reactive(Map))
    // ensure that the nested reactive `Map` can do tracking for itself
    target.get(key)
  }
}
```

## set

set 函数作用和主要做的以下2件事情：

- 区分操作是新增还是修改
- 调用 trigger 函数派发更新

```ts
function set(this: MapTypes, key: unknown, value: unknown) {
  value = toRaw(value)
  const target = toRaw(this)
  const { has, get } = getProto(target)

  let hadKey = has.call(target, key)
  if (!hadKey) {
    key = toRaw(key)
    hadKey = has.call(target, key)
  } else if (__DEV__) {
    checkIdentityKeys(target, has, key)
  }

  const oldValue = get.call(target, key)
  target.set(key, value)
  if (!hadKey) {
    trigger(target, TriggerOpTypes.ADD, key, value)
  } else if (hasChanged(value, oldValue)) {
    trigger(target, TriggerOpTypes.SET, key, value, oldValue)
  }
  return this
}
```

最后总结下 handler，当 target 是 Object 和 Array 时，handler 为 mutableHandlers，会劫持 get,set,has,deleteProperty,ownKeys,对属性进行依赖收集和派发更新；当 target 是 Map,Set,WeakMap,WeakSet时，handler 为 mutableCollectionHandlers，只拦截 get，对方法进行依赖收集和派发更新